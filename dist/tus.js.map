{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "lib/browser/fileReader.js",
    "lib/browser/fileSignature.js",
    "lib/browser/httpStack.js",
    "lib/browser/index.js",
    "lib/browser/isReactNative.js",
    "lib/browser/sources/FileSource.js",
    "lib/browser/sources/StreamSource.js",
    "lib/browser/sources/isCordova.js",
    "lib/browser/sources/readAsByteArray.js",
    "lib/browser/uriToBlob.js",
    "lib/browser/urlStorage.js",
    "lib/error.js",
    "lib/logger.js",
    "lib/noopUrlStorage.js",
    "lib/upload.js",
    "lib/uuid.js",
    "node_modules/base64-js/index.js",
    "node_modules/buffer/index.js",
    "node_modules/ieee754/index.js",
    "node_modules/js-base64/base64.js",
    "node_modules/querystringify/index.js",
    "node_modules/requires-port/index.js",
    "node_modules/url-parse/index.js"
  ],
  "names": [],
  "mappings": "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AC,SAAS,GAAG,CAAC,CAAC,CAAC,GAAG,GAAG,SAAS;EAEpC,OAAO,KAAK;AACd;AAEA,UAAU,CAAC,cAAc,GAAG,cAAc;AAAA,eAE3B,UAAU;AAAA;;;;;;;;;ACv+BzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAAS,IAAI,GAAI;EAC9B;EACA,OAAO,sCAAsC,CAAC,OAAO,CAAC,OAAO,EAAE,UAAC,CAAC,EAAK;IACpE,IAAM,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC;IAChC,IAAM,CAAC,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,GAAK,CAAC,GAAG,GAAG,GAAI,GAAI;IAC3C,OAAO,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC;EACvB,CAAC,CAAC;AACJ;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "import isReactNative from './isReactNative.js'\r\nimport uriToBlob from './uriToBlob.js'\r\n\r\nimport FileSource from './sources/FileSource.js'\r\nimport StreamSource from './sources/StreamSource.js'\r\n\r\nexport default class FileReader {\r\n  openFile (input, chunkSize) {\r\n    // In React Native, when user selects a file, instead of a File or Blob,\r\n    // you usually get a file object {} with a uri property that contains\r\n    // a local path to the file. We use XMLHttpRequest to fetch\r\n    // the file blob, before uploading with tus.\r\n    if (isReactNative() && input && typeof input.uri !== 'undefined') {\r\n      return uriToBlob(input.uri)\r\n        .then((blob) => new FileSource(blob))\r\n        .catch((err) => {\r\n          throw new Error(`tus: cannot fetch \\`file.uri\\` as Blob, make sure the uri is correct and accessible. ${err}`)\r\n        })\r\n    }\r\n\r\n    // Since we emulate the Blob type in our tests (not all target browsers\r\n    // support it), we cannot use `instanceof` for testing whether the input value\r\n    // can be handled. Instead, we simply check is the slice() function and the\r\n    // size property are available.\r\n    if (typeof input.slice === 'function' && typeof input.size !== 'undefined') {\r\n      return Promise.resolve(new FileSource(input))\r\n    }\r\n\r\n    if (typeof input.read === 'function') {\r\n      chunkSize = Number(chunkSize)\r\n      if (!Number.isFinite(chunkSize)) {\r\n        return Promise.reject(new Error('cannot create source for stream without a finite value for the `chunkSize` option'))\r\n      }\r\n\r\n      return Promise.resolve(new StreamSource(input, chunkSize))\r\n    }\r\n\r\n    return Promise.reject(new Error('source object may only be an instance of File, Blob, or Reader in this environment'))\r\n  }\r\n}\r\n",
    "import isReactNative from './isReactNative.js'\r\n\r\n// TODO: Differenciate between input types\r\n\r\n/**\r\n * Generate a fingerprint for a file which will be used the store the endpoint\r\n *\r\n * @param {File} file\r\n * @param {Object} options\r\n * @param {Function} callback\r\n */\r\nexport default function fingerprint (file, options) {\r\n  if (isReactNative()) {\r\n    return Promise.resolve(reactNativeFingerprint(file, options))\r\n  }\r\n\r\n  return Promise.resolve([\r\n    'tus-br',\r\n    file.name,\r\n    file.type,\r\n    file.size,\r\n    file.lastModified,\r\n    options.endpoint,\r\n  ].join('-'))\r\n}\r\n\r\nfunction reactNativeFingerprint (file, options) {\r\n  const exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : 'noexif'\r\n  return [\r\n    'tus-rn',\r\n    file.name || 'noname',\r\n    file.size || 'nosize',\r\n    exifHash,\r\n    options.endpoint,\r\n  ].join('/')\r\n}\r\n\r\nfunction hashCode (str) {\r\n  /* eslint-disable no-bitwise */\r\n  // from https://stackoverflow.com/a/8831937/151666\r\n  let hash = 0\r\n  if (str.length === 0) {\r\n    return hash\r\n  }\r\n  for (let i = 0; i < str.length; i++) {\r\n    const char = str.charCodeAt(i)\r\n    hash = ((hash << 5) - hash) + char\r\n    hash &= hash // Convert to 32bit integer\r\n  }\r\n  return hash\r\n}\r\n",
    "/* eslint-disable max-classes-per-file */\r\nexport default class XHRHttpStack {\r\n  createRequest (method, url) {\r\n    return new Request(method, url)\r\n  }\r\n\r\n  getName () {\r\n    return 'XHRHttpStack'\r\n  }\r\n}\r\n\r\nclass Request {\r\n  constructor (method, url) {\r\n    this._xhr = new XMLHttpRequest()\r\n    this._xhr.open(method, url, true)\r\n\r\n    this._method = method\r\n    this._url = url\r\n    this._headers = {}\r\n  }\r\n\r\n  getMethod () {\r\n    return this._method\r\n  }\r\n\r\n  getURL () {\r\n    return this._url\r\n  }\r\n\r\n  setHeader (header, value) {\r\n    this._xhr.setRequestHeader(header, value)\r\n    this._headers[header] = value\r\n  }\r\n\r\n  getHeader (header) {\r\n    return this._headers[header]\r\n  }\r\n\r\n  setProgressHandler (progressHandler) {\r\n    // Test support for progress events before attaching an event listener\r\n    if (!('upload' in this._xhr)) {\r\n      return\r\n    }\r\n\r\n    this._xhr.upload.onprogress = (e) => {\r\n      if (!e.lengthComputable) {\r\n        return\r\n      }\r\n\r\n      progressHandler(e.loaded)\r\n    }\r\n  }\r\n\r\n  send (body = null) {\r\n    return new Promise((resolve, reject) => {\r\n      this._xhr.onload = () => {\r\n        resolve(new Response(this._xhr))\r\n      }\r\n\r\n      this._xhr.onerror = (err) => {\r\n        reject(err)\r\n      }\r\n\r\n      this._xhr.send(body)\r\n    })\r\n  }\r\n\r\n  abort () {\r\n    this._xhr.abort()\r\n    return Promise.resolve()\r\n  }\r\n\r\n  getUnderlyingObject () {\r\n    return this._xhr\r\n  }\r\n}\r\n\r\nclass Response {\r\n  constructor (xhr) {\r\n    this._xhr = xhr\r\n  }\r\n\r\n  getStatus () {\r\n    return this._xhr.status\r\n  }\r\n\r\n  getHeader (header) {\r\n    return this._xhr.getResponseHeader(header)\r\n  }\r\n\r\n  getBody () {\r\n    return this._xhr.responseText\r\n  }\r\n\r\n  getUnderlyingObject () {\r\n    return this._xhr\r\n  }\r\n}\r\n",
    "import BaseUpload from '../upload.js'\r\nimport NoopUrlStorage from '../noopUrlStorage.js'\r\nimport { enableDebugLog } from '../logger.js'\r\nimport DetailedError from '../error.js'\r\n\r\nimport { canStoreURLs, WebStorageUrlStorage } from './urlStorage.js'\r\nimport DefaultHttpStack from './httpStack.js'\r\nimport FileReader from './fileReader.js'\r\nimport fingerprint from './fileSignature.js'\r\n\r\nconst defaultOptions = {\r\n  ...BaseUpload.defaultOptions,\r\n  httpStack : new DefaultHttpStack(),\r\n  fileReader: new FileReader(),\r\n  urlStorage: (canStoreURLs ? new WebStorageUrlStorage() : new NoopUrlStorage()),\r\n  fingerprint,\r\n}\r\n\r\nclass Upload extends BaseUpload {\r\n  constructor (file = null, options = {}) {\r\n    options = { ...defaultOptions, ...options }\r\n    super(file, options)\r\n  }\r\n\r\n  static terminate (url, options = {}) {\r\n    options = { ...defaultOptions, ...options }\r\n    return BaseUpload.terminate(url, options)\r\n  }\r\n}\r\n\r\nconst { XMLHttpRequest, Blob } = window\r\n\r\nconst isSupported = (\r\n  XMLHttpRequest\r\n  && Blob\r\n  && typeof Blob.prototype.slice === 'function'\r\n)\r\n\r\nexport {\r\n  Upload,\r\n  canStoreURLs,\r\n  defaultOptions,\r\n  isSupported,\r\n  enableDebugLog,\r\n  DefaultHttpStack,\r\n  DetailedError,\r\n}\r\n",
    "const isReactNative = () => (typeof navigator !== 'undefined'\r\n  && typeof navigator.product === 'string'\r\n  && navigator.product.toLowerCase() === 'reactnative')\r\n\r\nexport default isReactNative\r\n",
    "import isCordova from './isCordova.js'\r\nimport readAsByteArray from './readAsByteArray.js'\r\n\r\nexport default class FileSource {\r\n  // Make this.size a method\r\n  constructor (file) {\r\n    this._file = file\r\n    this.size = file.size\r\n  }\r\n\r\n  slice (start, end) {\r\n    // In Apache Cordova applications, a File must be resolved using\r\n    // FileReader instances, see\r\n    // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file\r\n    if (isCordova()) {\r\n      return readAsByteArray(this._file.slice(start, end))\r\n    }\r\n\r\n    const value = this._file.slice(start, end)\r\n    return Promise.resolve({ value })\r\n  }\r\n\r\n  close () {\r\n    // Nothing to do here since we don't need to release any resources.\r\n  }\r\n}\r\n",
    "function len (blobOrArray) {\r\n  if (blobOrArray === undefined) return 0\r\n  if (blobOrArray.size !== undefined) return blobOrArray.size\r\n  return blobOrArray.length\r\n}\r\n\r\n/*\r\n  Typed arrays and blobs don't have a concat method.\r\n  This function helps StreamSource accumulate data to reach chunkSize.\r\n*/\r\nfunction concat (a, b) {\r\n  if (a.concat) { // Is `a` an Array?\r\n    return a.concat(b)\r\n  }\r\n  if (a instanceof Blob) {\r\n    return new Blob([a, b], { type: a.type })\r\n  }\r\n  if (a.set) { // Is `a` a typed array?\r\n    const c = new a.constructor(a.length + b.length)\r\n    c.set(a)\r\n    c.set(b, a.length)\r\n    return c\r\n  }\r\n  throw new Error('Unknown data type')\r\n}\r\n\r\nexport default class StreamSource {\r\n  constructor (reader) {\r\n    this._buffer = undefined\r\n    this._bufferOffset = 0\r\n    this._reader = reader\r\n    this._done = false\r\n  }\r\n\r\n  slice (start, end) {\r\n    if (start < this._bufferOffset) {\r\n      return Promise.reject(new Error(\"Requested data is before the reader's current offset\"))\r\n    }\r\n\r\n    return this._readUntilEnoughDataOrDone(start, end)\r\n  }\r\n\r\n  _readUntilEnoughDataOrDone (start, end) {\r\n    const hasEnoughData = end <= this._bufferOffset + len(this._buffer)\r\n    if (this._done || hasEnoughData) {\r\n      const value = this._getDataFromBuffer(start, end)\r\n      const done = value == null ? this._done : false\r\n      return Promise.resolve({ value, done })\r\n    }\r\n\r\n    return this._reader.read().then(({ value, done }) => {\r\n      if (done) {\r\n        this._done = true\r\n      } else if (this._buffer === undefined) {\r\n        this._buffer = value\r\n      } else {\r\n        this._buffer = concat(this._buffer, value)\r\n      }\r\n\r\n      return this._readUntilEnoughDataOrDone(start, end)\r\n    })\r\n  }\r\n\r\n  _getDataFromBuffer (start, end) {\r\n    // Remove data from buffer before `start`.\r\n    // Data might be reread from the buffer if an upload fails, so we can only\r\n    // safely delete data when it comes *before* what is currently being read.\r\n    if (start > this._bufferOffset) {\r\n      this._buffer = this._buffer.slice(start - this._bufferOffset)\r\n      this._bufferOffset = start\r\n    }\r\n    // If the buffer is empty after removing old data, all data has been read.\r\n    const hasAllDataBeenRead = len(this._buffer) === 0\r\n    if (this._done && hasAllDataBeenRead) {\r\n      return null\r\n    }\r\n    // We already removed data before `start`, so we just return the first\r\n    // chunk from the buffer.\r\n    return this._buffer.slice(0, end - start)\r\n  }\r\n\r\n  close () {\r\n    if (this._reader.cancel) {\r\n      this._reader.cancel()\r\n    }\r\n  }\r\n}\r\n",
    "const isCordova = () => typeof window !== 'undefined' && (\r\n  typeof window.PhoneGap !== 'undefined'\r\n    || typeof window.Cordova !== 'undefined'\r\n    || typeof window.cordova !== 'undefined')\r\n\r\nexport default isCordova\r\n",
    "/**\r\n * readAsByteArray converts a File object to a Uint8Array.\r\n * This function is only used on the Apache Cordova platform.\r\n * See https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file/index.html#read-a-file\r\n */\r\nexport default function readAsByteArray (chunk) {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader()\r\n    reader.onload = () => {\r\n      const value = new Uint8Array(reader.result)\r\n      resolve({ value })\r\n    }\r\n    reader.onerror = (err) => {\r\n      reject(err)\r\n    }\r\n    reader.readAsArrayBuffer(chunk)\r\n  })\r\n}\r\n",
    "/**\r\n * uriToBlob resolves a URI to a Blob object. This is used for\r\n * React Native to retrieve a file (identified by a file://\r\n * URI) as a blob.\r\n */\r\nexport default function uriToBlob (uri) {\r\n  return new Promise((resolve, reject) => {\r\n    const xhr = new XMLHttpRequest()\r\n    xhr.responseType = 'blob'\r\n    xhr.onload = () => {\r\n      const blob = xhr.response\r\n      resolve(blob)\r\n    }\r\n    xhr.onerror = (err) => {\r\n      reject(err)\r\n    }\r\n    xhr.open('GET', uri)\r\n    xhr.send()\r\n  })\r\n}\r\n",
    "let hasStorage = false\r\ntry {\r\n  hasStorage = 'localStorage' in window\r\n\r\n  // Attempt to store and read entries from the local storage to detect Private\r\n  // Mode on Safari on iOS (see #49)\r\n  // If the key was not used before, we remove it from local storage again to\r\n  // not cause confusion where the entry came from.\r\n  const key = 'tusSupport'\r\n  const originalValue = localStorage.getItem(key)\r\n  localStorage.setItem(key, originalValue)\r\n  if (originalValue === null) localStorage.removeItem(key)\r\n} catch (e) {\r\n  // If we try to access localStorage inside a sandboxed iframe, a SecurityError\r\n  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is\r\n  // thrown (see #49)\r\n  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {\r\n    hasStorage = false\r\n  } else {\r\n    throw e\r\n  }\r\n}\r\n\r\nexport const canStoreURLs = hasStorage\r\n\r\nexport class WebStorageUrlStorage {\r\n  findAllUploads () {\r\n    const results = this._findEntries('tus::')\r\n    return Promise.resolve(results)\r\n  }\r\n\r\n  findUploadsByFingerprint (fingerprint) {\r\n    const results = this._findEntries(`tus::${fingerprint}::`)\r\n    return Promise.resolve(results)\r\n  }\r\n\r\n  removeUpload (urlStorageKey) {\r\n    localStorage.removeItem(urlStorageKey)\r\n    return Promise.resolve()\r\n  }\r\n\r\n  addUpload (fingerprint, upload) {\r\n    const id = Math.round(Math.random() * 1e12)\r\n    const key = `tus::${fingerprint}::${id}`\r\n\r\n    localStorage.setItem(key, JSON.stringify(upload))\r\n    return Promise.resolve(key)\r\n  }\r\n\r\n  _findEntries (prefix) {\r\n    const results = []\r\n\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i)\r\n      if (key.indexOf(prefix) !== 0) continue\r\n\r\n      try {\r\n        const upload = JSON.parse(localStorage.getItem(key))\r\n        upload.urlStorageKey = key\r\n\r\n        results.push(upload)\r\n      } catch (e) {\r\n        // The JSON parse error is intentionally ignored here, so a malformed\r\n        // entry in the storage cannot prevent an upload.\r\n      }\r\n    }\r\n\r\n    return results\r\n  }\r\n}\r\n",
    "class DetailedError extends Error {\r\n  constructor (message, causingErr = null, req = null, res = null) {\r\n    super(message)\r\n\r\n    this.originalRequest = req\r\n    this.originalResponse = res\r\n    this.causingError = causingErr\r\n\r\n    if (causingErr != null) {\r\n      message += `, caused by ${causingErr.toString()}`\r\n    }\r\n\r\n    if (req != null) {\r\n      const requestId = req.getHeader('X-Request-ID') || 'n/a'\r\n      const method = req.getMethod()\r\n      const url = req.getURL()\r\n      const status = res ? res.getStatus() : 'n/a'\r\n      const body = res ? (res.getBody() || '') : 'n/a'\r\n      message += `, originated from request (method: ${method}, url: ${url}, response code: ${status}, response text: ${body}, request id: ${requestId})`\r\n    }\r\n    this.message = message\r\n  }\r\n}\r\n\r\nexport default DetailedError\r\n",
    "/* eslint no-console: \"off\" */\r\n\r\nlet isEnabled = false\r\n\r\nexport function enableDebugLog () {\r\n  isEnabled = true\r\n}\r\n\r\nexport function log (msg) {\r\n  if (!isEnabled) return\r\n  console.log(msg)\r\n}\r\n",
    "/* eslint no-unused-vars: \"off\" */\r\n\r\nexport default class NoopUrlStorage {\r\n  listAllUploads () {\r\n    return Promise.resolve([])\r\n  }\r\n\r\n  findUploadsByFingerprint (fingerprint) {\r\n    return Promise.resolve([])\r\n  }\r\n\r\n  removeUpload (urlStorageKey) {\r\n    return Promise.resolve()\r\n  }\r\n\r\n  addUpload (fingerprint, upload) {\r\n    return Promise.resolve(null)\r\n  }\r\n}\r\n",
    "import { Base64 } from 'js-base64'\r\nimport URL from 'url-parse'\r\nimport DetailedError from './error.js'\r\nimport { log } from './logger.js'\r\nimport uuid from './uuid.js'\r\n\r\nconst defaultOptions = {\r\n  endpoint: null,\r\n\r\n  uploadUrl  : null,\r\n  metadata   : {},\r\n  fingerprint: null,\r\n  uploadSize : null,\r\n\r\n  onProgress          : null,\r\n  onChunkComplete     : null,\r\n  onSuccess           : null,\r\n  onError             : null,\r\n  onUploadUrlAvailable: null,\r\n\r\n  overridePatchMethod: false,\r\n  headers            : {},\r\n  addRequestId       : false,\r\n  onBeforeRequest    : null,\r\n  onAfterResponse    : null,\r\n  onShouldRetry      : null,\r\n\r\n  chunkSize                  : Infinity,\r\n  retryDelays                : [0, 1000, 3000, 5000],\r\n  parallelUploads            : 1,\r\n  parallelUploadBoundaries   : null,\r\n  storeFingerprintForResuming: true,\r\n  removeFingerprintOnSuccess : false,\r\n  uploadLengthDeferred       : false,\r\n  uploadDataDuringCreation   : false,\r\n\r\n  urlStorage: null,\r\n  fileReader: null,\r\n  httpStack : null,\r\n}\r\n\r\nclass BaseUpload {\r\n  constructor (file, options) {\r\n    // Warn about removed options from previous versions\r\n    if ('resume' in options) {\r\n      console.log('tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead.') // eslint-disable-line no-console\r\n    }\r\n\r\n    // The default options will already be added from the wrapper classes.\r\n    this.options = options\r\n\r\n    // Cast chunkSize to integer\r\n    this.options.chunkSize = Number(this.options.chunkSize)\r\n\r\n    // The storage module used to store URLs\r\n    this._urlStorage = this.options.urlStorage\r\n\r\n    // The underlying File/Blob object\r\n    this.file = file\r\n\r\n    // The URL against which the file will be uploaded\r\n    this.url = null\r\n\r\n    // The underlying request object for the current PATCH request\r\n    this._req = null\r\n\r\n    // The fingerpinrt for the current file (set after start())\r\n    this._fingerprint = null\r\n\r\n    // The key that the URL storage returned when saving an URL with a fingerprint,\r\n    this._urlStorageKey = null\r\n\r\n    // The offset used in the current PATCH request\r\n    this._offset = null\r\n\r\n    // True if the current PATCH request has been aborted\r\n    this._aborted = false\r\n\r\n    // The file's size in bytes\r\n    this._size = null\r\n\r\n    // The Source object which will wrap around the given file and provides us\r\n    // with a unified interface for getting its size and slice chunks from its\r\n    // content allowing us to easily handle Files, Blobs, Buffers and Streams.\r\n    this._source = null\r\n\r\n    // The current count of attempts which have been made. Zero indicates none.\r\n    this._retryAttempt = 0\r\n\r\n    // The timeout's ID which is used to delay the next retry\r\n    this._retryTimeout = null\r\n\r\n    // The offset of the remote upload before the latest attempt was started.\r\n    this._offsetBeforeRetry = 0\r\n\r\n    // An array of BaseUpload instances which are used for uploading the different\r\n    // parts, if the parallelUploads option is used.\r\n    this._parallelUploads = null\r\n\r\n    // An array of upload URLs which are used for uploading the different\r\n    // parts, if the parallelUploads option is used.\r\n    this._parallelUploadUrls = null\r\n  }\r\n\r\n  /**\r\n   * Use the Termination extension to delete an upload from the server by sending a DELETE\r\n   * request to the specified upload URL. This is only possible if the server supports the\r\n   * Termination extension. If the `options.retryDelays` property is set, the method will\r\n   * also retry if an error ocurrs.\r\n   *\r\n   * @param {String} url The upload's URL which will be terminated.\r\n   * @param {object} options Optional options for influencing HTTP requests.\r\n   * @return {Promise} The Promise will be resolved/rejected when the requests finish.\r\n   */\r\n  static terminate (url, options = {}) {\r\n    const req = openRequest('DELETE', url, options)\r\n\r\n    return sendRequest(req, null, options).then((res) => {\r\n      // A 204 response indicates a successfull request\r\n      if (res.getStatus() === 204) {\r\n        return\r\n      }\r\n\r\n      throw new DetailedError('tus: unexpected response while terminating upload', null, req, res)\r\n    }).catch((err) => {\r\n      if (!(err instanceof DetailedError)) {\r\n        err = new DetailedError('tus: failed to terminate upload', err, req, null)\r\n      }\r\n\r\n      if (!shouldRetry(err, 0, options)) {\r\n        throw err\r\n      }\r\n\r\n      // Instead of keeping track of the retry attempts, we remove the first element from the delays\r\n      // array. If the array is empty, all retry attempts are used up and we will bubble up the error.\r\n      // We recursively call the terminate function will removing elements from the retryDelays array.\r\n      const delay = options.retryDelays[0]\r\n      const remainingDelays = options.retryDelays.slice(1)\r\n      const newOptions = {\r\n        ...options,\r\n        retryDelays: remainingDelays,\r\n      }\r\n      return new Promise((resolve) => setTimeout(resolve, delay))\r\n        .then(() => BaseUpload.terminate(url, newOptions))\r\n    })\r\n  }\r\n\r\n  findPreviousUploads () {\r\n    return this.options.fingerprint(this.file, this.options)\r\n      .then((fingerprint) => this._urlStorage.findUploadsByFingerprint(fingerprint))\r\n  }\r\n\r\n  resumeFromPreviousUpload (previousUpload) {\r\n    this.url = previousUpload.uploadUrl || null\r\n    this._parallelUploadUrls = previousUpload.parallelUploadUrls || null\r\n    this._urlStorageKey = previousUpload.urlStorageKey\r\n  }\r\n\r\n  start () {\r\n    const { file } = this\r\n\r\n    if (!file) {\r\n      this._emitError(new Error('tus: no file or stream to upload provided'))\r\n      return\r\n    }\r\n\r\n    if (!this.options.endpoint && !this.options.uploadUrl && !this.url) {\r\n      this._emitError(new Error('tus: neither an endpoint or an upload URL is provided'))\r\n      return\r\n    }\r\n\r\n    const { retryDelays } = this.options\r\n    if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== '[object Array]') {\r\n      this._emitError(new Error('tus: the `retryDelays` option must either be an array or null'))\r\n      return\r\n    }\r\n\r\n    if (this.options.parallelUploads > 1) {\r\n      // Test which options are incompatible with parallel uploads.\r\n      for (const optionName of ['uploadUrl', 'uploadSize', 'uploadLengthDeferred']) {\r\n        if (this.options[optionName]) {\r\n          this._emitError(new Error(`tus: cannot use the ${optionName} option when parallelUploads is enabled`))\r\n          return\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.options.parallelUploadBoundaries) {\r\n      if (this.options.parallelUploads <= 1) {\r\n        this._emitError(new Error('tus: cannot use the `parallelUploadBoundaries` option when `parallelUploads` is disabled'))\r\n        return\r\n      }\r\n      if (this.options.parallelUploads !== this.options.parallelUploadBoundaries.length) {\r\n        this._emitError(new Error('tus: the `parallelUploadBoundaries` must have the same length as the value of `parallelUploads`'))\r\n        return\r\n      }\r\n    }\r\n\r\n    this.options.fingerprint(file, this.options)\r\n      .then((fingerprint) => {\r\n        if (fingerprint == null) {\r\n          log('No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.')\r\n        } else {\r\n          log(`Calculated fingerprint: ${fingerprint}`)\r\n        }\r\n\r\n        this._fingerprint = fingerprint\r\n\r\n        if (this._source) {\r\n          return this._source\r\n        }\r\n        return this.options.fileReader.openFile(file, this.options.chunkSize)\r\n      })\r\n      .then((source) => {\r\n        this._source = source\r\n\r\n        // First, we look at the uploadLengthDeferred option.\r\n        // Next, we check if the caller has supplied a manual upload size.\r\n        // Finally, we try to use the calculated size from the source object.\r\n        if (this.options.uploadLengthDeferred) {\r\n          this._size = null\r\n        } else if (this.options.uploadSize != null) {\r\n          this._size = Number(this.options.uploadSize)\r\n          if (Number.isNaN(this._size)) {\r\n            this._emitError(new Error('tus: cannot convert `uploadSize` option into a number'))\r\n            return\r\n          }\r\n        } else {\r\n          this._size = this._source.size\r\n          if (this._size == null) {\r\n            this._emitError(new Error(\"tus: cannot automatically derive upload's size from input. Specify it manually using the `uploadSize` option or use the `uploadLengthDeferred` option\"))\r\n            return\r\n          }\r\n        }\r\n\r\n        // If the upload was configured to use multiple requests or if we resume from\r\n        // an upload which used multiple requests, we start a parallel upload.\r\n        if (this.options.parallelUploads > 1 || this._parallelUploadUrls != null) {\r\n          this._startParallelUpload()\r\n        } else {\r\n          this._startSingleUpload()\r\n        }\r\n      })\r\n      .catch((err) => {\r\n        this._emitError(err)\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Initiate the uploading procedure for a parallelized upload, where one file is split into\r\n   * multiple request which are run in parallel.\r\n   *\r\n   * @api private\r\n   */\r\n  _startParallelUpload () {\r\n    const totalSize = this._size\r\n    let totalProgress = 0\r\n    this._parallelUploads = []\r\n\r\n    const partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads\r\n\r\n    // The input file will be split into multiple slices which are uploaded in separate\r\n    // requests. Here we get the start and end position for the slices.\r\n    const parts = this.options.parallelUploadBoundaries ?? splitSizeIntoParts(this._source.size, partCount)\r\n\r\n    // Attach URLs from previous uploads, if available.\r\n    if (this._parallelUploadUrls) {\r\n      parts.forEach((part, index) => {\r\n        part.uploadUrl = this._parallelUploadUrls[index] || null\r\n      })\r\n    }\r\n\r\n    // Create an empty list for storing the upload URLs\r\n    this._parallelUploadUrls = new Array(parts.length)\r\n\r\n    // Generate a promise for each slice that will be resolve if the respective\r\n    // upload is completed.\r\n    const uploads = parts.map((part, index) => {\r\n      let lastPartProgress = 0\r\n\r\n      return this._source.slice(part.start, part.end)\r\n        .then(({ value }) => new Promise((resolve, reject) => {\r\n          // Merge with the user supplied options but overwrite some values.\r\n          const options = {\r\n            ...this.options,\r\n            // If available, the partial upload should be resumed from a previous URL.\r\n            uploadUrl                  : part.uploadUrl || null,\r\n            // We take manually care of resuming for partial uploads, so they should\r\n            // not be stored in the URL storage.\r\n            storeFingerprintForResuming: false,\r\n            removeFingerprintOnSuccess : false,\r\n            // Reset the parallelUploads option to not cause recursion.\r\n            parallelUploads            : 1,\r\n            // Reset this option as we are not doing a parallel upload.\r\n            parallelUploadBoundaries   : null,\r\n            metadata                   : {},\r\n            // Add the header to indicate the this is a partial upload.\r\n            headers                    : {\r\n              ...this.options.headers,\r\n              'Upload-Concat': 'partial',\r\n            },\r\n            // Reject or resolve the promise if the upload errors or completes.\r\n            onSuccess : resolve,\r\n            onError   : reject,\r\n            // Based in the progress for this partial upload, calculate the progress\r\n            // for the entire final upload.\r\n            onProgress: (newPartProgress) => {\r\n              totalProgress = totalProgress - lastPartProgress + newPartProgress\r\n              lastPartProgress = newPartProgress\r\n              this._emitProgress(totalProgress, totalSize)\r\n            },\r\n            // Wait until every partial upload has an upload URL, so we can add\r\n            // them to the URL storage.\r\n            onUploadUrlAvailable: () => {\r\n              this._parallelUploadUrls[index] = upload.url\r\n              // Test if all uploads have received an URL\r\n              if (this._parallelUploadUrls.filter(u => Boolean(u)).length === parts.length) {\r\n                this._saveUploadInUrlStorage()\r\n              }\r\n            },\r\n          }\r\n\r\n          const upload = new BaseUpload(value, options)\r\n          upload.start()\r\n\r\n          // Store the upload in an array, so we can later abort them if necessary.\r\n          this._parallelUploads.push(upload)\r\n        }))\r\n    })\r\n\r\n    let req\r\n    // Wait until all partial uploads are finished and we can send the POST request for\r\n    // creating the final upload.\r\n    Promise.all(uploads).then(() => {\r\n      req = this._openRequest('POST', this.options.endpoint)\r\n      req.setHeader('Upload-Concat', `final;${this._parallelUploadUrls.join(' ')}`)\r\n\r\n      // Add metadata if values have been added\r\n      const metadata = encodeMetadata(this.options.metadata)\r\n      if (metadata !== '') {\r\n        req.setHeader('Upload-Metadata', metadata)\r\n      }\r\n\r\n      return this._sendRequest(req, null)\r\n    }).then((res) => {\r\n      if (!inStatusCategory(res.getStatus(), 200)) {\r\n        this._emitHttpError(req, res, 'tus: unexpected response while creating upload')\r\n        return\r\n      }\r\n\r\n      const location = res.getHeader('Location')\r\n      if (location == null) {\r\n        this._emitHttpError(req, res, 'tus: invalid or missing Location header')\r\n        return\r\n      }\r\n\r\n      this.url = resolveUrl(this.options.endpoint, location)\r\n      log(`Created upload at ${this.url}`)\r\n\r\n      this._emitSuccess()\r\n    }).catch((err) => {\r\n      this._emitError(err)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Initiate the uploading procedure for a non-parallel upload. Here the entire file is\r\n   * uploaded in a sequential matter.\r\n   *\r\n   * @api private\r\n   */\r\n  _startSingleUpload () {\r\n    // Reset the aborted flag when the upload is started or else the\r\n    // _performUpload will stop before sending a request if the upload has been\r\n    // aborted previously.\r\n    this._aborted = false\r\n\r\n    // The upload had been started previously and we should reuse this URL.\r\n    if (this.url != null) {\r\n      log(`Resuming upload from previous URL: ${this.url}`)\r\n      this._resumeUpload()\r\n      return\r\n    }\r\n\r\n    // A URL has manually been specified, so we try to resume\r\n    if (this.options.uploadUrl != null) {\r\n      log(`Resuming upload from provided URL: ${this.options.uploadUrl}`)\r\n      this.url = this.options.uploadUrl\r\n      this._resumeUpload()\r\n      return\r\n    }\r\n\r\n    // An upload has not started for the file yet, so we start a new one\r\n    log('Creating a new upload')\r\n    this._createUpload()\r\n  }\r\n\r\n  /**\r\n   * Abort any running request and stop the current upload. After abort is called, no event\r\n   * handler will be invoked anymore. You can use the `start` method to resume the upload\r\n   * again.\r\n   * If `shouldTerminate` is true, the `terminate` function will be called to remove the\r\n   * current upload from the server.\r\n   *\r\n   * @param {boolean} shouldTerminate True if the upload should be deleted from the server.\r\n   * @return {Promise} The Promise will be resolved/rejected when the requests finish.\r\n   */\r\n  abort (shouldTerminate) {\r\n    // Stop any parallel partial uploads, that have been started in _startParallelUploads.\r\n    if (this._parallelUploads != null) {\r\n      this._parallelUploads.forEach((upload) => {\r\n        upload.abort(shouldTerminate)\r\n      })\r\n    }\r\n\r\n    // Stop any current running request.\r\n    if (this._req !== null) {\r\n      this._req.abort()\r\n      // Note: We do not close the file source here, so the user can resume in the future.\r\n    }\r\n    this._aborted = true\r\n\r\n    // Stop any timeout used for initiating a retry.\r\n    if (this._retryTimeout != null) {\r\n      clearTimeout(this._retryTimeout)\r\n      this._retryTimeout = null\r\n    }\r\n\r\n    if (!shouldTerminate || this.url == null) {\r\n      return Promise.resolve()\r\n    }\r\n\r\n    return BaseUpload.terminate(this.url, this.options)\r\n      // Remove entry from the URL storage since the upload URL is no longer valid.\r\n      .then(() => this._removeFromUrlStorage())\r\n  }\r\n\r\n  _emitHttpError (req, res, message, causingErr) {\r\n    this._emitError(new DetailedError(message, causingErr, req, res))\r\n  }\r\n\r\n  _emitError (err) {\r\n    // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.\r\n    if (this._aborted) return\r\n\r\n    // Check if we should retry, when enabled, before sending the error to the user.\r\n    if (this.options.retryDelays != null) {\r\n      // We will reset the attempt counter if\r\n      // - we were already able to connect to the server (offset != null) and\r\n      // - we were able to upload a small chunk of data to the server\r\n      const shouldResetDelays = this._offset != null && (this._offset > this._offsetBeforeRetry)\r\n      if (shouldResetDelays) {\r\n        this._retryAttempt = 0\r\n      }\r\n\r\n      if (shouldRetry(err, this._retryAttempt, this.options)) {\r\n        const delay = this.options.retryDelays[this._retryAttempt++]\r\n\r\n        this._offsetBeforeRetry = this._offset\r\n\r\n        this._retryTimeout = setTimeout(() => {\r\n          this.start()\r\n        }, delay)\r\n        return\r\n      }\r\n    }\r\n\r\n    if (typeof this.options.onError === 'function') {\r\n      this.options.onError(err)\r\n    } else {\r\n      throw err\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Publishes notification if the upload has been successfully completed.\r\n   *\r\n   * @api private\r\n   */\r\n  _emitSuccess () {\r\n    if (this.options.removeFingerprintOnSuccess) {\r\n      // Remove stored fingerprint and corresponding endpoint. This causes\r\n      // new uploads of the same file to be treated as a different file.\r\n      this._removeFromUrlStorage()\r\n    }\r\n\r\n    if (typeof this.options.onSuccess === 'function') {\r\n      this.options.onSuccess()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Publishes notification when data has been sent to the server. This\r\n   * data may not have been accepted by the server yet.\r\n   *\r\n   * @param {number} bytesSent  Number of bytes sent to the server.\r\n   * @param {number} bytesTotal Total number of bytes to be sent to the server.\r\n   * @api private\r\n   */\r\n  _emitProgress (bytesSent, bytesTotal) {\r\n    if (typeof this.options.onProgress === 'function') {\r\n      this.options.onProgress(bytesSent, bytesTotal)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Publishes notification when a chunk of data has been sent to the server\r\n   * and accepted by the server.\r\n   * @param {number} chunkSize  Size of the chunk that was accepted by the server.\r\n   * @param {number} bytesAccepted Total number of bytes that have been\r\n   *                                accepted by the server.\r\n   * @param {number} bytesTotal Total number of bytes to be sent to the server.\r\n   * @api private\r\n   */\r\n  _emitChunkComplete (chunkSize, bytesAccepted, bytesTotal) {\r\n    if (typeof this.options.onChunkComplete === 'function') {\r\n      this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new upload using the creation extension by sending a POST\r\n   * request to the endpoint. After successful creation the file will be\r\n   * uploaded\r\n   *\r\n   * @api private\r\n   */\r\n  _createUpload () {\r\n    if (!this.options.endpoint) {\r\n      this._emitError(new Error('tus: unable to create upload because no endpoint is provided'))\r\n      return\r\n    }\r\n\r\n    const req = this._openRequest('POST', this.options.endpoint)\r\n\r\n    if (this.options.uploadLengthDeferred) {\r\n      req.setHeader('Upload-Defer-Length', 1)\r\n    } else {\r\n      req.setHeader('Upload-Length', this._size)\r\n    }\r\n\r\n    // Add metadata if values have been added\r\n    const metadata = encodeMetadata(this.options.metadata)\r\n    if (metadata !== '') {\r\n      req.setHeader('Upload-Metadata', metadata)\r\n    }\r\n\r\n    let promise\r\n    if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {\r\n      this._offset = 0\r\n      promise = this._addChunkToRequest(req)\r\n    } else {\r\n      promise = this._sendRequest(req, null)\r\n    }\r\n\r\n    promise.then((res) => {\r\n      if (!inStatusCategory(res.getStatus(), 200)) {\r\n        this._emitHttpError(req, res, 'tus: unexpected response while creating upload')\r\n        return\r\n      }\r\n\r\n      const location = res.getHeader('Location')\r\n      if (location == null) {\r\n        this._emitHttpError(req, res, 'tus: invalid or missing Location header')\r\n        return\r\n      }\r\n\r\n      this.url = resolveUrl(this.options.endpoint, location)\r\n      log(`Created upload at ${this.url}`)\r\n\r\n      if (typeof this.options.onUploadUrlAvailable === 'function') {\r\n        this.options.onUploadUrlAvailable()\r\n      }\r\n\r\n      if (this._size === 0) {\r\n        // Nothing to upload and file was successfully created\r\n        this._emitSuccess()\r\n        this._source.close()\r\n        return\r\n      }\r\n\r\n      this._saveUploadInUrlStorage()\r\n        .then(() => {\r\n          if (this.options.uploadDataDuringCreation) {\r\n            this._handleUploadResponse(req, res)\r\n          } else {\r\n            this._offset = 0\r\n            this._performUpload()\r\n          }\r\n        })\r\n    }).catch((err) => {\r\n      this._emitHttpError(req, null, 'tus: failed to create upload', err)\r\n    })\r\n  }\r\n\r\n  /*\r\n   * Try to resume an existing upload. First a HEAD request will be sent\r\n   * to retrieve the offset. If the request fails a new upload will be\r\n   * created. In the case of a successful response the file will be uploaded.\r\n   *\r\n   * @api private\r\n   */\r\n  _resumeUpload () {\r\n    const req = this._openRequest('HEAD', this.url)\r\n    const promise = this._sendRequest(req, null)\r\n\r\n    promise.then((res) => {\r\n      const status = res.getStatus()\r\n      if (!inStatusCategory(status, 200)) {\r\n        // If the upload is locked (indicated by the 423 Locked status code), we\r\n        // emit an error instead of directly starting a new upload. This way the\r\n        // retry logic can catch the error and will retry the upload. An upload\r\n        // is usually locked for a short period of time and will be available\r\n        // afterwards.\r\n        if (status === 423) {\r\n          this._emitHttpError(req, res, 'tus: upload is currently locked; retry later')\r\n          return\r\n        }\r\n\r\n        if (inStatusCategory(status, 400)) {\r\n          // Remove stored fingerprint and corresponding endpoint,\r\n          // on client errors since the file can not be found\r\n          this._removeFromUrlStorage()\r\n        }\r\n\r\n        if (!this.options.endpoint) {\r\n          // Don't attempt to create a new upload if no endpoint is provided.\r\n          this._emitHttpError(req, res, 'tus: unable to resume upload (new upload cannot be created without an endpoint)')\r\n          return\r\n        }\r\n\r\n        // Try to create a new upload\r\n        this.url = null\r\n        this._createUpload()\r\n        return\r\n      }\r\n\r\n      const offset = parseInt(res.getHeader('Upload-Offset'), 10)\r\n      if (Number.isNaN(offset)) {\r\n        this._emitHttpError(req, res, 'tus: invalid or missing offset value')\r\n        return\r\n      }\r\n\r\n      const length = parseInt(res.getHeader('Upload-Length'), 10)\r\n      if (Number.isNaN(length) && !this.options.uploadLengthDeferred) {\r\n        this._emitHttpError(req, res, 'tus: invalid or missing length value')\r\n        return\r\n      }\r\n\r\n      if (typeof this.options.onUploadUrlAvailable === 'function') {\r\n        this.options.onUploadUrlAvailable()\r\n      }\r\n\r\n      this._saveUploadInUrlStorage()\r\n        .then(() => {\r\n          // Upload has already been completed and we do not need to send additional\r\n          // data to the server\r\n          if (offset === length) {\r\n            this._emitProgress(length, length)\r\n            this._emitSuccess()\r\n            return\r\n          }\r\n\r\n          this._offset = offset\r\n          this._performUpload()\r\n        })\r\n    }).catch((err) => {\r\n      this._emitHttpError(req, null, 'tus: failed to resume upload', err)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Start uploading the file using PATCH requests. The file will be divided\r\n   * into chunks as specified in the chunkSize option. During the upload\r\n   * the onProgress event handler may be invoked multiple times.\r\n   *\r\n   * @api private\r\n   */\r\n  _performUpload () {\r\n    // If the upload has been aborted, we will not send the next PATCH request.\r\n    // This is important if the abort method was called during a callback, such\r\n    // as onChunkComplete or onProgress.\r\n    if (this._aborted) {\r\n      return\r\n    }\r\n\r\n    let req\r\n\r\n    // Some browser and servers may not support the PATCH method. For those\r\n    // cases, you can tell tus-js-client to use a POST request with the\r\n    // X-HTTP-Method-Override header for simulating a PATCH request.\r\n    if (this.options.overridePatchMethod) {\r\n      req = this._openRequest('POST', this.url)\r\n      req.setHeader('X-HTTP-Method-Override', 'PATCH')\r\n    } else {\r\n      req = this._openRequest('PATCH', this.url)\r\n    }\r\n\r\n    req.setHeader('Upload-Offset', this._offset)\r\n    const promise = this._addChunkToRequest(req)\r\n\r\n    promise.then((res) => {\r\n      if (!inStatusCategory(res.getStatus(), 200)) {\r\n        this._emitHttpError(req, res, 'tus: unexpected response while uploading chunk')\r\n        return\r\n      }\r\n\r\n      this._handleUploadResponse(req, res)\r\n    }).catch((err) => {\r\n      // Don't emit an error if the upload was aborted manually\r\n      if (this._aborted) {\r\n        return\r\n      }\r\n\r\n      this._emitHttpError(req, null, `tus: failed to upload chunk at offset ${this._offset}`, err)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * _addChunktoRequest reads a chunk from the source and sends it using the\r\n   * supplied request object. It will not handle the response.\r\n   *\r\n   * @api private\r\n   */\r\n  _addChunkToRequest (req) {\r\n    const start = this._offset\r\n    let end = this._offset + this.options.chunkSize\r\n\r\n    req.setProgressHandler((bytesSent) => {\r\n      this._emitProgress(start + bytesSent, this._size)\r\n    })\r\n\r\n    req.setHeader('Content-Type', 'application/offset+octet-stream')\r\n\r\n    // The specified chunkSize may be Infinity or the calcluated end position\r\n    // may exceed the file's size. In both cases, we limit the end position to\r\n    // the input's total size for simpler calculations and correctness.\r\n    if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {\r\n      end = this._size\r\n    }\r\n\r\n    return this._source.slice(start, end)\r\n      .then(({ value, done }) => {\r\n        // If the upload length is deferred, the upload size was not specified during\r\n        // upload creation. So, if the file reader is done reading, we know the total\r\n        // upload size and can tell the tus server.\r\n        if (this.options.uploadLengthDeferred && done) {\r\n          this._size = this._offset + (value && value.size ? value.size : 0)\r\n          req.setHeader('Upload-Length', this._size)\r\n        }\r\n\r\n        if (value === null) {\r\n          return this._sendRequest(req)\r\n        }\r\n        this._emitProgress(this._offset, this._size)\r\n        return this._sendRequest(req, value)\r\n      })\r\n  }\r\n\r\n  /**\r\n   * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest\r\n   * and already have received a response.\r\n   *\r\n   * @api private\r\n   */\r\n  _handleUploadResponse (req, res) {\r\n    const offset = parseInt(res.getHeader('Upload-Offset'), 10)\r\n    if (Number.isNaN(offset)) {\r\n      this._emitHttpError(req, res, 'tus: invalid or missing offset value')\r\n      return\r\n    }\r\n\r\n    this._emitProgress(offset, this._size)\r\n    this._emitChunkComplete(offset - this._offset, offset, this._size)\r\n\r\n    this._offset = offset\r\n\r\n    if (offset === this._size) {\r\n      // Yay, finally done :)\r\n      this._emitSuccess()\r\n      this._source.close()\r\n      return\r\n    }\r\n\r\n    this._performUpload()\r\n  }\r\n\r\n  /**\r\n   * Create a new HTTP request object with the given method and URL.\r\n   *\r\n   * @api private\r\n   */\r\n  _openRequest (method, url) {\r\n    const req = openRequest(method, url, this.options)\r\n    this._req = req\r\n    return req\r\n  }\r\n\r\n  /**\r\n   * Remove the entry in the URL storage, if it has been saved before.\r\n   *\r\n   * @api private\r\n   */\r\n  _removeFromUrlStorage () {\r\n    if (!this._urlStorageKey) return\r\n\r\n    this._urlStorage.removeUpload(this._urlStorageKey).catch((err) => {\r\n      this._emitError(err)\r\n    })\r\n    this._urlStorageKey = null\r\n  }\r\n\r\n  /**\r\n   * Add the upload URL to the URL storage, if possible.\r\n   *\r\n   * @api private\r\n   */\r\n  _saveUploadInUrlStorage () {\r\n    // We do not store the upload URL\r\n    // - if it was disabled in the option, or\r\n    // - if no fingerprint was calculated for the input (i.e. a stream), or\r\n    // - if the URL is already stored (i.e. key is set alread).\r\n    if (!this.options.storeFingerprintForResuming || !this._fingerprint || this._urlStorageKey !== null) {\r\n      return Promise.resolve()\r\n    }\r\n\r\n    const storedUpload = {\r\n      size        : this._size,\r\n      metadata    : this.options.metadata,\r\n      creationTime: new Date().toString(),\r\n    }\r\n\r\n    if (this._parallelUploads) {\r\n      // Save multiple URLs if the parallelUploads option is used ...\r\n      storedUpload.parallelUploadUrls = this._parallelUploadUrls\r\n    } else {\r\n      // ... otherwise we just save the one available URL.\r\n      storedUpload.uploadUrl = this.url\r\n    }\r\n\r\n    return this._urlStorage.addUpload(this._fingerprint, storedUpload)\r\n      .then((urlStorageKey) => { this._urlStorageKey = urlStorageKey })\r\n  }\r\n\r\n  /**\r\n   * Send a request with the provided body.\r\n   *\r\n   * @api private\r\n   */\r\n  _sendRequest (req, body = null) {\r\n    return sendRequest(req, body, this.options)\r\n  }\r\n}\r\n\r\nfunction encodeMetadata (metadata) {\r\n  return Object.entries(metadata)\r\n    .map(([key, value]) => `${key} ${Base64.encode(String(value))}`)\r\n    .join(',')\r\n}\r\n\r\n/**\r\n * Checks whether a given status is in the range of the expected category.\r\n * For example, only a status between 200 and 299 will satisfy the category 200.\r\n *\r\n * @api private\r\n */\r\nfunction inStatusCategory (status, category) {\r\n  return (status >= category && status < (category + 100))\r\n}\r\n\r\n/**\r\n * Create a new HTTP request with the specified method and URL.\r\n * The necessary headers that are included in every request\r\n * will be added, including the request ID.\r\n *\r\n * @api private\r\n */\r\nfunction openRequest (method, url, options) {\r\n  const req = options.httpStack.createRequest(method, url)\r\n\r\n  req.setHeader('Tus-Resumable', '1.0.0')\r\n  const headers = options.headers || {}\r\n\r\n  Object.entries(headers)\r\n    .forEach(([name, value]) => { req.setHeader(name, value) })\r\n\r\n  if (options.addRequestId) {\r\n    const requestId = uuid()\r\n    req.setHeader('X-Request-ID', requestId)\r\n  }\r\n\r\n  return req\r\n}\r\n\r\n/**\r\n * Send a request with the provided body while invoking the onBeforeRequest\r\n * and onAfterResponse callbacks.\r\n *\r\n * @api private\r\n */\r\nfunction sendRequest (req, body, options) {\r\n  const onBeforeRequestPromise = (typeof options.onBeforeRequest === 'function')\r\n    ? Promise.resolve(options.onBeforeRequest(req))\r\n    : Promise.resolve()\r\n\r\n  return onBeforeRequestPromise.then(() => {\r\n    return req.send(body)\r\n      .then((res) => {\r\n        const onAfterResponsePromise = (typeof options.onAfterResponse === 'function')\r\n          ? Promise.resolve(options.onAfterResponse(req, res))\r\n          : Promise.resolve()\r\n\r\n        return onAfterResponsePromise.then(() => res)\r\n      })\r\n  })\r\n}\r\n\r\n/**\r\n * Checks whether the browser running this code has internet access.\r\n * This function will always return true in the node.js environment\r\n *\r\n * @api private\r\n */\r\nfunction isOnline () {\r\n  let online = true\r\n  if (typeof window !== 'undefined'\r\n        && 'navigator' in window // eslint-disable-line no-undef\r\n        && window.navigator.onLine === false) { // eslint-disable-line no-undef\r\n    online = false\r\n  }\r\n\r\n  return online\r\n}\r\n\r\n/**\r\n * Checks whether or not it is ok to retry a request.\r\n * @param {Error} err the error returned from the last request\r\n * @param {number} retryAttempt the number of times the request has already been retried\r\n * @param {object} options tus Upload options\r\n *\r\n * @api private\r\n */\r\nfunction shouldRetry (err, retryAttempt, options) {\r\n  // We only attempt a retry if\r\n  // - retryDelays option is set\r\n  // - we didn't exceed the maxium number of retries, yet, and\r\n  // - this error was caused by a request or it's response and\r\n  // - the error is server error (i.e. not a status 4xx except a 409 or 423) or\r\n  // a onShouldRetry is specified and returns true\r\n  // - the browser does not indicate that we are offline\r\n  if (options.retryDelays == null || retryAttempt >= options.retryDelays.length || err.originalRequest == null) {\r\n    return false\r\n  }\r\n\r\n  if (options && typeof options.onShouldRetry === 'function') {\r\n    return options.onShouldRetry(err, retryAttempt, options)\r\n  }\r\n\r\n  const status = err.originalResponse ? err.originalResponse.getStatus() : 0\r\n  return (!inStatusCategory(status, 400) || status === 409 || status === 423) && isOnline()\r\n}\r\n\r\n/**\r\n * Resolve a relative link given the origin as source. For example,\r\n * if a HTTP request to http://example.com/files/ returns a Location\r\n * header with the value /upload/abc, the resolved URL will be:\r\n * http://example.com/upload/abc\r\n */\r\nfunction resolveUrl (origin, link) {\r\n  return new URL(link, origin).toString()\r\n}\r\n\r\n/**\r\n * Calculate the start and end positions for the parts if an upload\r\n * is split into multiple parallel requests.\r\n *\r\n * @param {number} totalSize The byte size of the upload, which will be split.\r\n * @param {number} partCount The number in how many parts the upload will be split.\r\n * @return {object[]}\r\n * @api private\r\n */\r\nfunction splitSizeIntoParts (totalSize, partCount) {\r\n  const partSize = Math.floor(totalSize / partCount)\r\n  const parts = []\r\n\r\n  for (let i = 0; i < partCount; i++) {\r\n    parts.push({\r\n      start: partSize * i,\r\n      end  : partSize * (i + 1),\r\n    })\r\n  }\r\n\r\n  parts[partCount - 1].end = totalSize\r\n\r\n  return parts\r\n}\r\n\r\nBaseUpload.defaultOptions = defaultOptions\r\n\r\nexport default BaseUpload\r\n",
    "/**\r\n * Generate a UUID v4 based on random numbers. We intentioanlly use the less\r\n * secure Math.random function here since the more secure crypto.getRandomNumbers\r\n * is not available on all platforms.\r\n * This is not a problem for us since we use the UUID only for generating a\r\n * request ID, so we can correlate server logs to client errors.\r\n *\r\n * This function is taken from following site:\r\n * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\r\n *\r\n * @return {string} The generate UUID\r\n */\r\nexport default function uuid () {\r\n  /* eslint-disable no-bitwise */\r\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n    const r = Math.random() * 16 | 0\r\n    const v = c === 'x' ? r : ((r & 0x3) | 0x8)\r\n    return v.toString(16)\r\n  })\r\n}\r\n",
    "'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n",
    "/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n",
    "/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n",
    "//\n// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!\n//\n;\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined'\n        ? module.exports = factory()\n        : typeof define === 'function' && define.amd\n            ? define(factory) :\n            // cf. https://github.com/dankogai/js-base64/issues/119\n            (function () {\n                // existing version for noConflict()\n                var _Base64 = global.Base64;\n                var gBase64 = factory();\n                gBase64.noConflict = function () {\n                    global.Base64 = _Base64;\n                    return gBase64;\n                };\n                if (global.Meteor) { // Meteor.js\n                    Base64 = gBase64;\n                }\n                global.Base64 = gBase64;\n            })();\n}((typeof self !== 'undefined' ? self\n    : typeof window !== 'undefined' ? window\n        : typeof global !== 'undefined' ? global\n            : this), function () {\n    'use strict';\n    /**\n     *  base64.ts\n     *\n     *  Licensed under the BSD 3-Clause License.\n     *    http://opensource.org/licenses/BSD-3-Clause\n     *\n     *  References:\n     *    http://en.wikipedia.org/wiki/Base64\n     *\n     * @author Dan Kogai (https://github.com/dankogai)\n     */\n    var version = '3.7.4';\n    /**\n     * @deprecated use lowercase `version`.\n     */\n    var VERSION = version;\n    var _hasatob = typeof atob === 'function';\n    var _hasbtoa = typeof btoa === 'function';\n    var _hasBuffer = typeof Buffer === 'function';\n    var _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\n    var _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\n    var b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var b64chs = Array.prototype.slice.call(b64ch);\n    var b64tab = (function (a) {\n        var tab = {};\n        a.forEach(function (c, i) { return tab[c] = i; });\n        return tab;\n    })(b64chs);\n    var b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\n    var _fromCC = String.fromCharCode.bind(String);\n    var _U8Afrom = typeof Uint8Array.from === 'function'\n        ? Uint8Array.from.bind(Uint8Array)\n        : function (it, fn) {\n            if (fn === void 0) { fn = function (x) { return x; }; }\n            return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));\n        };\n    var _mkUriSafe = function (src) { return src\n        .replace(/=/g, '').replace(/[+\\/]/g, function (m0) { return m0 == '+' ? '-' : '_'; }); };\n    var _tidyB64 = function (s) { return s.replace(/[^A-Za-z0-9\\+\\/]/g, ''); };\n    /**\n     * polyfill version of `btoa`\n     */\n    var btoaPolyfill = function (bin) {\n        // console.log('polyfilled');\n        var u32, c0, c1, c2, asc = '';\n        var pad = bin.length % 3;\n        for (var i = 0; i < bin.length;) {\n            if ((c0 = bin.charCodeAt(i++)) > 255 ||\n                (c1 = bin.charCodeAt(i++)) > 255 ||\n                (c2 = bin.charCodeAt(i++)) > 255)\n                throw new TypeError('invalid character found');\n            u32 = (c0 << 16) | (c1 << 8) | c2;\n            asc += b64chs[u32 >> 18 & 63]\n                + b64chs[u32 >> 12 & 63]\n                + b64chs[u32 >> 6 & 63]\n                + b64chs[u32 & 63];\n        }\n        return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n    };\n    /**\n     * does what `window.btoa` of web browsers do.\n     * @param {String} bin binary string\n     * @returns {string} Base64-encoded string\n     */\n    var _btoa = _hasbtoa ? function (bin) { return btoa(bin); }\n        : _hasBuffer ? function (bin) { return Buffer.from(bin, 'binary').toString('base64'); }\n            : btoaPolyfill;\n    var _fromUint8Array = _hasBuffer\n        ? function (u8a) { return Buffer.from(u8a).toString('base64'); }\n        : function (u8a) {\n            // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n            var maxargs = 0x1000;\n            var strs = [];\n            for (var i = 0, l = u8a.length; i < l; i += maxargs) {\n                strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n            }\n            return _btoa(strs.join(''));\n        };\n    /**\n     * converts a Uint8Array to a Base64 string.\n     * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5\n     * @returns {string} Base64 string\n     */\n    var fromUint8Array = function (u8a, urlsafe) {\n        if (urlsafe === void 0) { urlsafe = false; }\n        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n    };\n    // This trick is found broken https://github.com/dankogai/js-base64/issues/130\n    // const utob = (src: string) => unescape(encodeURIComponent(src));\n    // reverting good old fationed regexp\n    var cb_utob = function (c) {\n        if (c.length < 2) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c\n                : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                    + _fromCC(0x80 | (cc & 0x3f)))\n                    : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                        + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                        + _fromCC(0x80 | (cc & 0x3f)));\n        }\n        else {\n            var cc = 0x10000\n                + (c.charCodeAt(0) - 0xD800) * 0x400\n                + (c.charCodeAt(1) - 0xDC00);\n            return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n                + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n                + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                + _fromCC(0x80 | (cc & 0x3f)));\n        }\n    };\n    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n    /**\n     * @deprecated should have been internal use only.\n     * @param {string} src UTF-8 string\n     * @returns {string} UTF-16 string\n     */\n    var utob = function (u) { return u.replace(re_utob, cb_utob); };\n    //\n    var _encode = _hasBuffer\n        ? function (s) { return Buffer.from(s, 'utf8').toString('base64'); }\n        : _TE\n            ? function (s) { return _fromUint8Array(_TE.encode(s)); }\n            : function (s) { return _btoa(utob(s)); };\n    /**\n     * converts a UTF-8-encoded string to a Base64 string.\n     * @param {boolean} [urlsafe] if `true` make the result URL-safe\n     * @returns {string} Base64 string\n     */\n    var encode = function (src, urlsafe) {\n        if (urlsafe === void 0) { urlsafe = false; }\n        return urlsafe\n            ? _mkUriSafe(_encode(src))\n            : _encode(src);\n    };\n    /**\n     * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.\n     * @returns {string} Base64 string\n     */\n    var encodeURI = function (src) { return encode(src, true); };\n    // This trick is found broken https://github.com/dankogai/js-base64/issues/130\n    // const btou = (src: string) => decodeURIComponent(escape(src));\n    // reverting good old fationed regexp\n    var re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\n    var cb_btou = function (cccc) {\n        switch (cccc.length) {\n            case 4:\n                var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                    | ((0x3f & cccc.charCodeAt(1)) << 12)\n                    | ((0x3f & cccc.charCodeAt(2)) << 6)\n                    | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n                return (_fromCC((offset >>> 10) + 0xD800)\n                    + _fromCC((offset & 0x3FF) + 0xDC00));\n            case 3:\n                return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                    | ((0x3f & cccc.charCodeAt(1)) << 6)\n                    | (0x3f & cccc.charCodeAt(2)));\n            default:\n                return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                    | (0x3f & cccc.charCodeAt(1)));\n        }\n    };\n    /**\n     * @deprecated should have been internal use only.\n     * @param {string} src UTF-16 string\n     * @returns {string} UTF-8 string\n     */\n    var btou = function (b) { return b.replace(re_btou, cb_btou); };\n    /**\n     * polyfill version of `atob`\n     */\n    var atobPolyfill = function (asc) {\n        // console.log('polyfilled');\n        asc = asc.replace(/\\s+/g, '');\n        if (!b64re.test(asc))\n            throw new TypeError('malformed base64.');\n        asc += '=='.slice(2 - (asc.length & 3));\n        var u24, bin = '', r1, r2;\n        for (var i = 0; i < asc.length;) {\n            u24 = b64tab[asc.charAt(i++)] << 18\n                | b64tab[asc.charAt(i++)] << 12\n                | (r1 = b64tab[asc.charAt(i++)]) << 6\n                | (r2 = b64tab[asc.charAt(i++)]);\n            bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n                : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                    : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n        }\n        return bin;\n    };\n    /**\n     * does what `window.atob` of web browsers do.\n     * @param {String} asc Base64-encoded string\n     * @returns {string} binary string\n     */\n    var _atob = _hasatob ? function (asc) { return atob(_tidyB64(asc)); }\n        : _hasBuffer ? function (asc) { return Buffer.from(asc, 'base64').toString('binary'); }\n            : atobPolyfill;\n    //\n    var _toUint8Array = _hasBuffer\n        ? function (a) { return _U8Afrom(Buffer.from(a, 'base64')); }\n        : function (a) { return _U8Afrom(_atob(a), function (c) { return c.charCodeAt(0); }); };\n    /**\n     * converts a Base64 string to a Uint8Array.\n     */\n    var toUint8Array = function (a) { return _toUint8Array(_unURI(a)); };\n    //\n    var _decode = _hasBuffer\n        ? function (a) { return Buffer.from(a, 'base64').toString('utf8'); }\n        : _TD\n            ? function (a) { return _TD.decode(_toUint8Array(a)); }\n            : function (a) { return btou(_atob(a)); };\n    var _unURI = function (a) { return _tidyB64(a.replace(/[-_]/g, function (m0) { return m0 == '-' ? '+' : '/'; })); };\n    /**\n     * converts a Base64 string to a UTF-8 string.\n     * @param {String} src Base64 string.  Both normal and URL-safe are supported\n     * @returns {string} UTF-8 string\n     */\n    var decode = function (src) { return _decode(_unURI(src)); };\n    /**\n     * check if a value is a valid Base64 string\n     * @param {String} src a value to check\n      */\n    var isValid = function (src) {\n        if (typeof src !== 'string')\n            return false;\n        var s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n        return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n    };\n    //\n    var _noEnum = function (v) {\n        return {\n            value: v, enumerable: false, writable: true, configurable: true\n        };\n    };\n    /**\n     * extend String.prototype with relevant methods\n     */\n    var extendString = function () {\n        var _add = function (name, body) { return Object.defineProperty(String.prototype, name, _noEnum(body)); };\n        _add('fromBase64', function () { return decode(this); });\n        _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n        _add('toBase64URI', function () { return encode(this, true); });\n        _add('toBase64URL', function () { return encode(this, true); });\n        _add('toUint8Array', function () { return toUint8Array(this); });\n    };\n    /**\n     * extend Uint8Array.prototype with relevant methods\n     */\n    var extendUint8Array = function () {\n        var _add = function (name, body) { return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body)); };\n        _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n        _add('toBase64URI', function () { return fromUint8Array(this, true); });\n        _add('toBase64URL', function () { return fromUint8Array(this, true); });\n    };\n    /**\n     * extend Builtin prototypes with relevant methods\n     */\n    var extendBuiltins = function () {\n        extendString();\n        extendUint8Array();\n    };\n    var gBase64 = {\n        version: version,\n        VERSION: VERSION,\n        atob: _atob,\n        atobPolyfill: atobPolyfill,\n        btoa: _btoa,\n        btoaPolyfill: btoaPolyfill,\n        fromBase64: decode,\n        toBase64: encode,\n        encode: encode,\n        encodeURI: encodeURI,\n        encodeURL: encodeURI,\n        utob: utob,\n        btou: btou,\n        decode: decode,\n        isValid: isValid,\n        fromUint8Array: fromUint8Array,\n        toUint8Array: toUint8Array,\n        extendString: extendString,\n        extendUint8Array: extendUint8Array,\n        extendBuiltins: extendBuiltins\n    };\n    //\n    // export Base64 to the namespace\n    //\n    // ES5 is yet to have Object.assign() that may make transpilers unhappy.\n    // gBase64.Base64 = Object.assign({}, gBase64);\n    gBase64.Base64 = {};\n    Object.keys(gBase64).forEach(function (k) { return gBase64.Base64[k] = gBase64[k]; });\n    return gBase64;\n}));\n",
    "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , undef;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Attempts to encode a given input.\n *\n * @param {String} input The string that needs to be encoded.\n * @returns {String|Null} The encoded string.\n * @api private\n */\nfunction encode(input) {\n  try {\n    return encodeURIComponent(input);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?#&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  while (part = parser.exec(query)) {\n    var key = decode(part[1])\n      , value = decode(part[2]);\n\n    //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = []\n    , value\n    , key;\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key];\n\n      //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encode(key);\n      value = encode(value);\n\n      //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n      if (key === null || value === null) continue;\n      pairs.push(key +'='+ value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n",
    "'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n",
    "'use strict';\n\nvar required = require('requires-port')\n  , qs = require('querystringify')\n  , controlOrWhitespace = /^[\\x00-\\x20\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/\n  , CRHTLF = /[\\n\\r\\t]/g\n  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//\n  , port = /:\\d+$/\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\\\/]+)?([\\S\\s]*)/i\n  , windowsDriveLetter = /^[a-zA-Z]:/;\n\n/**\n * Remove control characters and whitespace from the beginning of a string.\n *\n * @param {Object|String} str String to trim.\n * @returns {String} A new string representing `str` stripped of control\n *     characters and whitespace from its beginning.\n * @public\n */\nfunction trimLeft(str) {\n  return (str ? str : '').toString().replace(controlOrWhitespace, '');\n}\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  function sanitize(address, url) {     // Sanitize what is left of the address\n    return isSpecial(url.protocol) ? address.replace(/\\\\/g, '/') : address;\n  },\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d*)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 };\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\nfunction lolcation(loc) {\n  var globalVar;\n\n  if (typeof window !== 'undefined') globalVar = window;\n  else if (typeof global !== 'undefined') globalVar = global;\n  else if (typeof self !== 'undefined') globalVar = self;\n  else globalVar = {};\n\n  var location = globalVar.location || {};\n  loc = loc || location;\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n\n/**\n * Check whether a protocol scheme is special.\n *\n * @param {String} The protocol scheme of the URL\n * @return {Boolean} `true` if the protocol scheme is special, else `false`\n * @private\n */\nfunction isSpecial(scheme) {\n  return (\n    scheme === 'file:' ||\n    scheme === 'ftp:' ||\n    scheme === 'http:' ||\n    scheme === 'https:' ||\n    scheme === 'ws:' ||\n    scheme === 'wss:'\n  );\n}\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @param {Object} location\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\nfunction extractProtocol(address, location) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n  location = location || {};\n\n  var match = protocolre.exec(address);\n  var protocol = match[1] ? match[1].toLowerCase() : '';\n  var forwardSlashes = !!match[2];\n  var otherSlashes = !!match[3];\n  var slashesCount = 0;\n  var rest;\n\n  if (forwardSlashes) {\n    if (otherSlashes) {\n      rest = match[2] + match[3] + match[4];\n      slashesCount = match[2].length + match[3].length;\n    } else {\n      rest = match[2] + match[4];\n      slashesCount = match[2].length;\n    }\n  } else {\n    if (otherSlashes) {\n      rest = match[3] + match[4];\n      slashesCount = match[3].length;\n    } else {\n      rest = match[4]\n    }\n  }\n\n  if (protocol === 'file:') {\n    if (slashesCount >= 2) {\n      rest = rest.slice(2);\n    }\n  } else if (isSpecial(protocol)) {\n    rest = match[4];\n  } else if (protocol) {\n    if (forwardSlashes) {\n      rest = rest.slice(2);\n    }\n  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {\n    rest = match[4];\n  }\n\n  return {\n    protocol: protocol,\n    slashes: forwardSlashes || isSpecial(protocol),\n    slashesCount: slashesCount,\n    rest: rest\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\nfunction resolve(relative, base) {\n  if (relative === '') return base;\n\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} [location] Location defaults for relative paths.\n * @param {Boolean|Function} [parser] Parser for the query string.\n * @private\n */\nfunction Url(address, location, parser) {\n  address = trimLeft(address);\n  address = address.replace(CRHTLF, '');\n\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '', location);\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (\n    extracted.protocol === 'file:' && (\n      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||\n    (!extracted.slashes &&\n      (extracted.protocol ||\n        extracted.slashesCount < 2 ||\n        !isSpecial(url.protocol)))\n  ) {\n    instructions[3] = [/(.*)/, 'pathname'];\n  }\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address, url);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      index = parse === '@'\n        ? address.lastIndexOf(parse)\n        : address.indexOf(parse);\n\n      if (~index) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if ((index = parse.exec(address))) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // Default to a / for pathname if none exists. This normalizes the URL\n  // to always have a /\n  //\n  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {\n    url.pathname = '/' + url.pathname;\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n\n  if (url.auth) {\n    index = url.auth.indexOf(':');\n\n    if (~index) {\n      url.username = url.auth.slice(0, index);\n      url.username = encodeURIComponent(decodeURIComponent(url.username));\n\n      url.password = url.auth.slice(index + 1);\n      url.password = encodeURIComponent(decodeURIComponent(url.password))\n    } else {\n      url.username = encodeURIComponent(decodeURIComponent(url.auth));\n    }\n\n    url.auth = url.password ? url.username +':'+ url.password : url.username;\n  }\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || qs.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!required(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) value += ':'+ url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (port.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n      break;\n\n    case 'username':\n    case 'password':\n      url[part] = encodeURIComponent(value);\n      break;\n\n    case 'auth':\n      var index = value.indexOf(':');\n\n      if (~index) {\n        url.username = value.slice(0, index);\n        url.username = encodeURIComponent(decodeURIComponent(url.username));\n\n        url.password = value.slice(index + 1);\n        url.password = encodeURIComponent(decodeURIComponent(url.password));\n      } else {\n        url.username = encodeURIComponent(decodeURIComponent(value));\n      }\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.auth = url.password ? url.username +':'+ url.password : url.username;\n\n  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n}\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , host = url.host\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result =\n    protocol +\n    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  } else if (url.password) {\n    result += ':'+ url.password;\n    result += '@';\n  } else if (\n    url.protocol !== 'file:' &&\n    isSpecial(url.protocol) &&\n    !host &&\n    url.pathname !== '/'\n  ) {\n    //\n    // Add back the empty userinfo, otherwise the original invalid URL\n    // might be transformed into a valid one with `url.pathname` as host.\n    //\n    result += '@';\n  }\n\n  //\n  // Trailing colon is removed from `url.host` when it is parsed. If it still\n  // ends with a colon, then add back the trailing colon that was removed. This\n  // prevents an invalid URL from being transformed into a valid one.\n  //\n  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {\n    host += ':';\n  }\n\n  result += host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n}\n\nUrl.prototype = { set: set, toString: toString };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.trimLeft = trimLeft;\nUrl.qs = qs;\n\nmodule.exports = Url;\n"
  ]
}